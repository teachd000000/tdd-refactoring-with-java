# 3주차

## 클린코드

#### 르블랑의 법칙

우리 모두는 쓰레기 코드를 보며 나중에 손보겠다고 생각한다. 하지만,
> 나중은 결코 오지 않는다.

#### 프로그래밍이란?
- 프로그래밍이란 기계가 실행할 정도로 요구사항을 명시하는 작업이 프로그래밍이다.
- 요구사항은 기계가 실행할 정도로 엄밀하고, 정확하고, 상세하고, 정형적이어야한다.
- 코드를 자동화하려면 요구사항을 애매하게 주어도 사람의 의도를 정확히 꿰뚤어 프로그램을 완벽하게 실행할수 있어야한다.

---

## 로또 게임 피드백

#### 우선 기능을 분리한다.
- 로또 생성
	- 자동 생성
	- 수동 생성
- 로또 비교
	- 1개의 로또 비교
	- N개의 로또 비교
- 당첨금 계산
- 수익률 계산

#### TDD 구현 순서
1. Lotto
2. LottoResult
3. WinningLotto
4. Validation Check
5. LottoNo

---

## TDD 작성팁
- Input 과 Output 을 통해 메소드를 설계한다.
- 꼭 필요한 테스트 케이스만 추가한다.
- 컴파일 에러가 발생하지 않는 방향으로 점진적으로 리팩토링한다.
- 객체를 가지고 비교하기 떄문에 equals(), hashCode(), toString() 메서드를 정의해야한다.
- 테스트 코드가 비교적 적을때 리팩토링을 많이 해야한다.
- 라이프사이클이 같은 변수들은 객체로 묶는다.
- 변수명이 클래스명이 되는 경우가 많다.
- 가능한 private 과 final 을 같이 사용하는것이 좋다.
- 메서드가 서로 상호작용을 할 경우, 어디에 있는 것이 좋을지에 대해 고민한다.
- 가능한 접근제한자는 최소한으로 만든다.
- 생성자가 많아질 경우, 정적 팩토리 메서드(from)를 사용해 가독성을 높인다.
- 상황에 맞는 자료구조로 유효성 체크를 한다.
- 유효성 체크를 객체밖에서 하지말고, 객체안에서 하도록 한다.
- 코드의 중복이 발생하는 과도기적인 단계를 두면서 개발한다.
- VO(변경이 불가능함) 와 DTO(변경 가능함) 는 다르다.
- Map 을 이용해서 객체를 재사용할 수 있다.

---

## 리팩토링 원칙
1. 메소드 인자 원칙
 - 3개는 가능한 피하는 편이 좋다. 4개 이상은 특별한 이유가 있어도 사용하면 안된다.
2. 일급 Collection을 쓴다.
 - Collection을 포함한 클래스는 반드시 다른 멤버 변수가 없어야 한다.
 - 각 Collection은 그 자체로 포장돼 있으므로 이제 Collection과 관련한 로직을 이 객체가 담당하도록 구현할 수 있다.
3. 상속(is-a 관계)보다는 조합(has-a 관계)을 사용하도록 한다.
4. 모든 원시값과 문자열을 포장한다.
 - primitive type과 String 기반으로 구현하는 부분이 있다면 객체로 포장하는 것을 고려해본다.
5. 적절한 Collection(자료구조)을 활용하라.
6. 생성자 대신 정적 팩토리 메서드를 사용하라.
 - 이름을 가짐으로써 객체 생성의 의도를 드러낼 수 있다.
 - 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.
7. int 상수 대신 enum을 활용하라
8. 가능한 불변 객체로 만든다.
 - 객체의 상태를 변경하는 메소드를 제공하지 않는다.
 - 클래스를 확장할 수 없도록 한다.(public final class)
 - 모든 필드를 final로 선언한다.
 - 모든 필드를 private으로 선언한다.
9. 테스트 가능한 상태로 만든다.
10. 의존객체 주입해서 사용한다.

---

 